# 内存策略示例

这个示例展示了 LangGraphGo 中所有 9 种可用的内存管理策略。

## 概述

内存管理对于 AI 代理在控制 token 成本的同时保持上下文至关重要。本示例展示如何使用每种策略的实际演示。

## 演示的策略

### 1. 顺序内存（Sequential Memory - 保留全部）
- **使用场景**：成本无关紧要的短对话
- **行为**：无限制地存储所有消息
- **演示**：展示对所有交互的完美回忆

### 2. 滑动窗口内存（Sliding Window Memory）
- **使用场景**：有界历史的聊天
- **行为**：仅保留最近的 N 条消息
- **演示**：添加 5 条消息但只保留最后 3 条

### 3. 缓冲内存（Buffer Memory）
- **使用场景**：通用目的，灵活限制
- **行为**：可按消息数或 token 数限制
- **演示**：限制为 3 条消息并跟踪 token 使用

### 4. 摘要式内存（Summarization Memory）
- **使用场景**：需要压缩的长对话
- **行为**：摘要旧消息，完整保留最近消息
- **演示**：达到阈值后自动创建摘要

### 5. 检索式内存（Retrieval Memory）
- **使用场景**：查询驱动访问的大型知识库
- **行为**：使用相似度检索最相关的消息
- **演示**：查询"编程语言"并检索相关消息

### 6. 分层内存（Hierarchical Memory）
- **使用场景**：具有不同重要性级别的复杂对话
- **行为**：分离重要和最近的消息
- **演示**：标记重要消息并展示它们被保留

### 7. 图式内存（Graph-Based Memory）
- **使用场景**：跟踪主题之间的关系
- **行为**：构建消息连接的知识图谱
- **演示**：跟踪主题关系并检索相关联的消息

### 8. 压缩式内存（Compression Memory）
- **使用场景**：长对话的积极压缩
- **行为**：将消息压缩成块并进行整合
- **演示**：显示压缩率和块创建

### 9. 类操作系统内存（OS-Like Memory）
- **使用场景**：复杂的内存生命周期管理
- **行为**：多层内存（活跃/缓存/归档）和 LRU 淘汰
- **演示**：展示分页和内存层分布

## 运行示例

```bash
cd examples/memory_strategies
go run main.go
```

## 预期输出

程序将为每种策略演示：
- 策略描述
- 内存使用统计
- 消息存储/检索示例
- 策略特定指标（压缩率、关系等）

## 关键见解

1. **顺序内存**：最适合短对话，无优化
2. **滑动窗口**：简单可预测，适合聊天
3. **缓冲内存**：灵活的中间方案
4. **摘要式**：适合保留上下文的长对话
5. **检索式**：非常适合大型知识库
6. **分层式**：适合复杂的多主题对话
7. **图式**：关系很重要时的最佳选择
8. **压缩式**：最大空间效率
9. **类OS**：最复杂，处理复杂访问模式

## 选择策略

| 您的场景 | 推荐策略 |
|---------|---------|
| 短聊天（< 10 条消息） | 顺序内存 |
| 固定历史的持续对话 | 滑动窗口 |
| 通用聊天机器人 | 缓冲内存 |
| 长时间咨询会话 | 摘要式 |
| 知识库问答 | 检索式 |
| 多主题讨论 | 分层式 |
| 基于主题的导航 | 图式 |
| 成本敏感的长对话 | 压缩式 |
| 具有不同访问的复杂代理 | 类OS |

## 自定义

每种策略都接受配置选项。请参阅 main.go 文件和[内存包文档](../../memory/README_CN.md)了解自定义详情：
- 窗口大小
- 重要性评分函数
- 自定义摘要器
- 嵌入函数
- 压缩触发器
- 内存限制

## 扩展阅读

- [Memory Package Documentation](../../memory/README.md)
- [内存包文档（中文）](../../memory/README_CN.md)
