package main

import (
	"time"

	"github.com/tmc/langchaingo/llms"
)

// ResearchState represents the state of the research process
type ResearchState struct {
	// Input
	Query        string `json:"query"`         // Original research query
	ResearchGoal string `json:"research_goal"` // Specific research goal or focus

	// Planning Phase
	Questions        []string `json:"questions"`         // Research questions generated by planner
	PlanningComplete bool     `json:"planning_complete"` // Whether planning is done

	// Execution Phase
	SearchResults     []SearchResult  `json:"search_results"`     // All search results
	Summaries         []SourceSummary `json:"summaries"`          // Summaries of sources
	ExecutionComplete bool            `json:"execution_complete"` // Whether execution is done

	// Publishing Phase
	FinalReport    string `json:"final_report"`    // Final research report
	ReportComplete bool   `json:"report_complete"` // Whether report is generated

	// Metadata
	Sources      []Source  `json:"sources"`       // All sources used
	TotalSources int       `json:"total_sources"` // Total number of sources
	Iteration    int       `json:"iteration"`     // Current iteration
	StartTime    time.Time `json:"start_time"`    // Research start time
	EndTime      time.Time `json:"end_time"`      // Research end time

	// LLM Messages for context
	Messages []llms.MessageContent `json:"messages"`
}

// SearchResult represents a single search result
type SearchResult struct {
	URL        string  `json:"url"`
	Title      string  `json:"title"`
	Content    string  `json:"content"`
	Score      float64 `json:"score"`
	Question   string  `json:"question"`    // Which question this result is for
	RawContent string  `json:"raw_content"` // Full content from web scraping
}

// SourceSummary represents a summary of a source
type SourceSummary struct {
	URL       string   `json:"url"`
	Title     string   `json:"title"`
	Summary   string   `json:"summary"`
	Relevance float64  `json:"relevance"`
	Question  string   `json:"question"`
	KeyPoints []string `json:"key_points"`
}

// Source represents a cited source in the report
type Source struct {
	URL          string `json:"url"`
	Title        string `json:"title"`
	Citation     string `json:"citation"`       // How to cite this source
	UsedInReport bool   `json:"used_in_report"` // Whether this source was cited
}

// ResearchQuestion represents a structured research question
type ResearchQuestion struct {
	Question string `json:"question"`
	Context  string `json:"context"`
	Priority int    `json:"priority"`
	Category string `json:"category"`
}

// NewResearchState creates a new research state
func NewResearchState(query string) *ResearchState {
	return &ResearchState{
		Query:             query,
		Questions:         []string{},
		SearchResults:     []SearchResult{},
		Summaries:         []SourceSummary{},
		Sources:           []Source{},
		Messages:          []llms.MessageContent{},
		StartTime:         time.Now(),
		PlanningComplete:  false,
		ExecutionComplete: false,
		ReportComplete:    false,
	}
}

// AddQuestion adds a research question to the state
func (s *ResearchState) AddQuestion(question string) {
	s.Questions = append(s.Questions, question)
}

// AddSearchResult adds a search result to the state
func (s *ResearchState) AddSearchResult(result SearchResult) {
	s.SearchResults = append(s.SearchResults, result)
}

// AddSummary adds a source summary to the state
func (s *ResearchState) AddSummary(summary SourceSummary) {
	s.Summaries = append(s.Summaries, summary)
}

// AddSource adds a source to the state
func (s *ResearchState) AddSource(source Source) {
	s.Sources = append(s.Sources, source)
	s.TotalSources = len(s.Sources)
}

// GetTopSummaries returns the top N summaries by relevance
func (s *ResearchState) GetTopSummaries(n int) []SourceSummary {
	if len(s.Summaries) <= n {
		return s.Summaries
	}

	// Sort by relevance (simple implementation)
	summaries := make([]SourceSummary, len(s.Summaries))
	copy(summaries, s.Summaries)

	// TODO: Implement proper sorting by relevance

	return summaries[:n]
}

// GetSummariesForQuestion returns summaries for a specific question
func (s *ResearchState) GetSummariesForQuestion(question string) []SourceSummary {
	var filtered []SourceSummary
	for _, summary := range s.Summaries {
		if summary.Question == question {
			filtered = append(filtered, summary)
		}
	}
	return filtered
}
